import { openApiSpec } from "./openapi.js";
import { writeFileSync, mkdirSync } from "fs";
import { dirname } from "path";

/**
 * Generate SQL schema from OpenAPI specification
 */
export function generateSqlSchema(includeFileDbPragmas: boolean = true): string {
  const schemas = openApiSpec.getSchemas();
  const lines: string[] = [];

  lines.push(`-- Generated SQL schema from OpenAPI specification for SQLite`);
  lines.push(`-- Do not edit this file manually - it will be overwritten`);
  lines.push(`-- Note: Some PRAGMA settings are only applied for file databases, not in-memory`);
  lines.push(``);

  // Essential PRAGMA settings that work for all database types
  lines.push(`-- Essential PRAGMA settings for SQLite`);
  lines.push(`PRAGMA foreign_keys = ON; -- Enforce foreign key constraints`);
  lines.push(`PRAGMA busy_timeout = 5000; -- Set a timeout for busy locks (in milliseconds)`);

  // File database specific settings
  if (includeFileDbPragmas) {
    lines.push(`-- File database specific settings (comment out for in-memory databases)`);
    lines.push(`PRAGMA journal_mode = WAL; -- Enable Write-Ahead Logging for better concurrency`);
    lines.push(`PRAGMA synchronous = NORMAL; -- Balance safety and performance`);
    lines.push(`PRAGMA temp_store = MEMORY; -- Store temporary tables in memory`);
    lines.push(
      `PRAGMA mmap_size = 268435456; -- Use memory mapping for better performance (256MB)`,
    );
    lines.push(`PRAGMA cache_size = -64000; -- Set cache size to 64MB`);
  }

  lines.push(``);

  lines.push(`BEGIN TRANSACTION;`);
  lines.push(``);

  for (const [schemaName, schema] of Object.entries(schemas)) {
    const typedSchema = schema as any;
    if (typedSchema.type === "object" && typedSchema.properties) {
      lines.push(`-- Table for ${schemaName}`);
      lines.push(`CREATE TABLE IF NOT EXISTS ${toSnakeCase(schemaName)} (`);

      const columns: string[] = [];

      // Check if schema already has an id field
      const hasIdField = Object.keys(typedSchema.properties).some(
        (prop) => toSnakeCase(prop).toLowerCase() === "id",
      );

      // Add a standard primary key only if not already defined
      if (!hasIdField) {
        columns.push(`  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL`);
      }

      for (const [propName, propSchema] of Object.entries(typedSchema.properties)) {
        const prop = propSchema as any;
        const columnName = toSnakeCase(propName);

        // Handle existing id field as primary key
        if (columnName.toLowerCase() === "id") {
          const sqlType = getSqlType(prop);
          columns.push(`  ${columnName} ${sqlType} PRIMARY KEY NOT NULL`);
          continue;
        }

        const sqlType = getSqlType(prop);
        const nullable = typedSchema.required?.includes(propName) ? "NOT NULL" : "NULL";

        // Add default values for certain types
        let defaultValue = "";
        if (!typedSchema.required?.includes(propName)) {
          if (prop.type === "boolean") {
            defaultValue = " DEFAULT 0";
          } else if (prop.type === "string" && prop.format === "date-time") {
            defaultValue = " DEFAULT CURRENT_TIMESTAMP";
          }
        }

        columns.push(`  ${columnName} ${sqlType} ${nullable}${defaultValue}`);
      }

      lines.push(columns.join(",\n"));
      lines.push(`);`);
      lines.push(``);

      // Add indexes for commonly queried fields
      addCommonIndexes(lines, schemaName, typedSchema);
    }
  }

  lines.push(`COMMIT;`);
  lines.push(``);

  return lines.join("\n");
}

/**
 * Convert camelCase to snake_case
 */
function toSnakeCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}

/**
 * Convert OpenAPI type to SQL type
 */
function getSqlType(schema: any): string {
  switch (schema.type) {
    case "string":
      if (schema.format === "date-time") {
        return "TEXT"; // Store as ISO 8601 string (YYYY-MM-DD HH:MM:SS)
      }
      if (schema.format === "date") {
        return "TEXT"; // Store as ISO 8601 date (YYYY-MM-DD)
      }
      if (schema.format === "uuid") {
        return "TEXT"; // UUIDs are typically 36 characters
      }
      if (schema.format === "email") {
        return "TEXT"; // Email addresses
      }
      if (schema.format === "uri" || schema.format === "url") {
        return "TEXT"; // URLs can be quite long
      }
      if (schema.maxLength) {
        // For very short strings, we might want to be more specific
        if (schema.maxLength <= 255) {
          return `VARCHAR(${schema.maxLength})`;
        }
        return "TEXT"; // For longer strings, just use TEXT
      }
      if (schema.enum && schema.enum.length > 0) {
        // For enums, use TEXT but could potentially use CHECK constraints
        return "TEXT"; // Could add: CHECK (column_name IN ('value1', 'value2', ...))
      }
      return "TEXT";

    case "integer":
      if (schema.format === "int64") {
        return "INTEGER"; // SQLite INTEGER is 64-bit
      }
      if (schema.format === "int32") {
        return "INTEGER"; // Still use INTEGER, SQLite will handle the range
      }
      // Check for specific integer constraints
      if (schema.minimum !== undefined && schema.minimum >= 0) {
        return "INTEGER"; // Positive integers - could add CHECK constraints
      }
      return "INTEGER";

    case "number":
      if (schema.format === "float") {
        return "REAL"; // 32-bit floating point
      }
      if (schema.format === "double") {
        return "REAL"; // 64-bit floating point (SQLite REAL is double precision)
      }
      if (schema.format === "decimal") {
        return "TEXT"; // For precise decimal arithmetic, store as text
      }
      return "REAL"; // General floating-point number

    case "boolean":
      return "INTEGER"; // SQLite uses 0 for false, 1 for true

    case "array":
      return "TEXT"; // Store JSON arrays as TEXT (could also use JSON1 extension)

    case "object":
      return "TEXT"; // Store JSON objects as TEXT (could also use JSON1 extension)

    default:
      return "TEXT"; // Safe default fallback
  }
}

/**
 * Generate SQL schema file from OpenAPI specification
 */
export function generateSqlSchemaFile(
  outputPath: string = "./schema.sql",
  includeFileDbPragmas: boolean = true,
): void {
  const sqlContent = generateSqlSchema(includeFileDbPragmas);

  // Ensure the directory exists
  const dir = dirname(outputPath);
  mkdirSync(dir, { recursive: true });

  // Write the SQL file
  writeFileSync(outputPath, sqlContent, "utf8");
  console.log(`SQL schema generated: ${outputPath}`);

  if (!includeFileDbPragmas) {
    console.log(
      `Note: File database PRAGMA settings were excluded (suitable for in-memory databases)`,
    );
  }
}

/**
 * Add common indexes for frequently queried fields
 */
function addCommonIndexes(lines: string[], schemaName: string, schema: any): void {
  const tableName = toSnakeCase(schemaName);
  const indexes: string[] = [];

  // Common field patterns that typically need indexes
  const indexableFields = [
    "email",
    "username",
    "phone",
    "status",
    "type",
    "created_at",
    "updated_at",
    "due_date",
    "rental_date",
    "customer_id",
    "video_id",
    "rental_id",
    "payment_id",
  ];

  for (const [propName] of Object.entries(schema.properties)) {
    const columnName = toSnakeCase(propName);

    // Add index for commonly queried fields
    if (indexableFields.includes(columnName)) {
      indexes.push(
        `CREATE INDEX IF NOT EXISTS idx_${tableName}_${columnName} ON ${tableName}(${columnName});`,
      );
    }

    // Add index for foreign key fields (ending with _id)
    if (columnName.endsWith("_id") && columnName !== "id") {
      indexes.push(
        `CREATE INDEX IF NOT EXISTS idx_${tableName}_${columnName} ON ${tableName}(${columnName});`,
      );
    }
  }

  if (indexes.length > 0) {
    lines.push(`-- Indexes for ${schemaName}`);
    indexes.forEach((index) => lines.push(index));
    lines.push(``);
  }
}
